## 39 数组中出现次数超过一半的数字

#### 题目：

数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。

#### 解题（快排）：

- 如果把数组排序，那么这个中位数所在的位置必然是这个数。

- 快排算法的`partition(nums, low, high)`函数，随机从数组中找到一个位置，使得这个位置的数大于左区间，小于右区间。如果直接找到就中位数，就直接返回中位数。
- 如果不是中位数，那么就一直找，最差也就是把数组排序了。

```java
public static int MoreThanHalfNum_Solution(int [] array) {
        
        //1 数组判空
        if(array==null || array.length==0) return -1;
        
        //2 寻找中位数
        int len = array.length;
        int low = 0;
        int high = len-1;
        
        //中位数
        int mid = len / 2;
        //index所在的元素，大于左边所有，小于右边所有
        int index = partition(array, low, high);
        
        while(index != mid){
            if(index > mid){
                index = partition(array, low, index-1);
            }else{
                index = partition(array, index+1, high);
            }
        }
        
        //3 检查这个数是不是真的是超过一半了(有些数组本来就没有超过一半的数)
        int result = array[index];
        int time = 0;
        for(int i=0; i<array.length; i++){
            if(array[i] == result){
                time += 1;
            }
        }
        
        if(time > mid){
            return result;
        }else{
            return -1;
        }
    }
    
	//在数组array的[low,high]找到一个位置，使得这个位置的数大于左区间，小于右区间
    public static int partition(int[] array, int low, int high){
        
        int temp = array[low];
        
        while(low<high){
            while(low<high && array[high] >= temp){ 
                high--;
            }
            array[low] = array[high];
            
            while(low<high && array[low] <= temp){ //等号，把自己忽略过去
                low++;
            }
            array[high] = array[low];
        }
        array[low] = temp;
        
        return low;
    }
```

